package me.travja.performances.api.models;

import com.amazonaws.services.dynamodbv2.datamodeling.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import lombok.Data;
import lombok.NoArgsConstructor;
import me.travja.performances.api.Util;
import me.travja.performances.serializers.PersonSerializer;
import me.travja.performances.serializers.ZonedDateTimeSerializer;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Data
@DynamoDBDocument
@NoArgsConstructor
@DynamoDBTable(tableName = "Performances")
public class Performance {

    private static DateTimeFormatter format = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss O");

    @DynamoDBAutoGeneratedKey
    @DynamoDBHashKey(attributeName = "id")
    private UUID                id;
    @DynamoDBAttribute(attributeName = "title")
    private String              title            = "No Title";
    @DynamoDBAttribute(attributeName = "venue")
    private String              venue            = "No Address";
    @DynamoDBAttribute(attributeName = "director")
    @JsonSerialize(using = PersonSerializer.class)
    private Director            director;
    @DynamoDBAttribute(attributeName = "castingDirector")
    @JsonSerialize(using = PersonSerializer.class)
    private CastingDirector     castingDirector;
    @DynamoDBAttribute(attributeName = "performanceDates")
    @DynamoDBTypeConverted(converter = ListDateTimeConverter.class)
    @JsonSerialize(contentUsing = ZonedDateTimeSerializer.class)
    private List<ZonedDateTime> performanceDates = new ArrayList<>();
    @DynamoDBAttribute(attributeName = "auditionList")
    @DynamoDBTypeConverted(converter = AuditionListConverter.class)
    private List<Audition>      auditionList     = new ArrayList<>();
    @DynamoDBAttribute(attributeName = "cast")
    @JsonSerialize(contentUsing = PersonSerializer.class)
    @DynamoDBTypeConverted(converter = CastListConverter.class)
    private List<Performer>     cast             = new ArrayList<>();

    public Performance(String title, String venue,
                       Director director, CastingDirector castingDirector,
                       List<ZonedDateTime> performanceDates, List<Performer> cast) {
        this.title = title;
        this.venue = venue;
        this.director = director;
        this.castingDirector = castingDirector;
        this.performanceDates = performanceDates;
        this.cast = cast;
    }

    public boolean ownsPerformance(Director director) {
        return this.director.equals(director) || castingDirector.equals(director);
    }

    public void cast(Performer performer) {
        Audition audition      = getAudition(performer);
        boolean  hasAuditioned = audition != null && audition.getDate().isBefore(ZonedDateTime.now());
        if (!hasAuditioned)
            throw new IllegalArgumentException("That performer has not auditioned for this performance.");

        audition.setStatus("Cast");

        if (!getCast().contains(performer)) {
            getCast().add(performer);
            performer.addCurrentPerformance(this);
            Util.sendEmail(performer, "You have been cast!",
                    "Congratulations! You have been cast in " +
                            getTitle() + "! We look forward to having you!");
        }
    }

    public Audition getAudition(Performer performer) {
        return getAudition(performer.getId());
    }

    public Audition getAudition(UUID performerId) {
        return auditionList.stream().filter(audition -> audition.getPerformer().getId().equals(performerId))
                .findFirst().orElse(null);
    }

    public Audition scheduleAudition(Performer performer, ZonedDateTime date) {
        if (isInAuditionList(performer))
            throw new IllegalArgumentException("That performer has already scheduled an audition for this performance.");

        Audition audition = new Audition(performer, date);
        auditionList.add(audition);
        return audition;
    }

    public boolean isInAuditionList(Performer performer) {
        return auditionList.stream()
                .anyMatch(audition -> audition.getPerformer().getId() == performer.getId());
    }

    public void removeAudition(UUID id) {
        auditionList.stream().filter(audition -> audition.getId().equals(id)).findFirst()
                .ifPresent(aud -> auditionList.remove(aud));
    }

//    public void loadCastList() {
//        if (cast instanceof LazyList) {
//            ((LazyList<Performer>) cast).load();
//            setCast(new ArrayList<>(cast));
//        }
//    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Performance that = (Performance) o;
        return id.equals(that.id);
    }
}
